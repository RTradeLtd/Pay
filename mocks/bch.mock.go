// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/gcash/bchd/bchrpc/pb"
	"google.golang.org/grpc"
)

type FakeBchrpcClient struct {
	GetAddressTransactionsStub        func(context.Context, *pb.GetAddressTransactionsRequest, ...grpc.CallOption) (*pb.GetAddressTransactionsResponse, error)
	getAddressTransactionsMutex       sync.RWMutex
	getAddressTransactionsArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetAddressTransactionsRequest
		arg3 []grpc.CallOption
	}
	getAddressTransactionsReturns struct {
		result1 *pb.GetAddressTransactionsResponse
		result2 error
	}
	getAddressTransactionsReturnsOnCall map[int]struct {
		result1 *pb.GetAddressTransactionsResponse
		result2 error
	}
	GetAddressUnspentOutputsStub        func(context.Context, *pb.GetAddressUnspentOutputsRequest, ...grpc.CallOption) (*pb.GetAddressUnspentOutputsResponse, error)
	getAddressUnspentOutputsMutex       sync.RWMutex
	getAddressUnspentOutputsArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetAddressUnspentOutputsRequest
		arg3 []grpc.CallOption
	}
	getAddressUnspentOutputsReturns struct {
		result1 *pb.GetAddressUnspentOutputsResponse
		result2 error
	}
	getAddressUnspentOutputsReturnsOnCall map[int]struct {
		result1 *pb.GetAddressUnspentOutputsResponse
		result2 error
	}
	GetBlockStub        func(context.Context, *pb.GetBlockRequest, ...grpc.CallOption) (*pb.GetBlockResponse, error)
	getBlockMutex       sync.RWMutex
	getBlockArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetBlockRequest
		arg3 []grpc.CallOption
	}
	getBlockReturns struct {
		result1 *pb.GetBlockResponse
		result2 error
	}
	getBlockReturnsOnCall map[int]struct {
		result1 *pb.GetBlockResponse
		result2 error
	}
	GetBlockFilterStub        func(context.Context, *pb.GetBlockFilterRequest, ...grpc.CallOption) (*pb.GetBlockFilterResponse, error)
	getBlockFilterMutex       sync.RWMutex
	getBlockFilterArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetBlockFilterRequest
		arg3 []grpc.CallOption
	}
	getBlockFilterReturns struct {
		result1 *pb.GetBlockFilterResponse
		result2 error
	}
	getBlockFilterReturnsOnCall map[int]struct {
		result1 *pb.GetBlockFilterResponse
		result2 error
	}
	GetBlockInfoStub        func(context.Context, *pb.GetBlockInfoRequest, ...grpc.CallOption) (*pb.GetBlockInfoResponse, error)
	getBlockInfoMutex       sync.RWMutex
	getBlockInfoArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetBlockInfoRequest
		arg3 []grpc.CallOption
	}
	getBlockInfoReturns struct {
		result1 *pb.GetBlockInfoResponse
		result2 error
	}
	getBlockInfoReturnsOnCall map[int]struct {
		result1 *pb.GetBlockInfoResponse
		result2 error
	}
	GetBlockchainInfoStub        func(context.Context, *pb.GetBlockchainInfoRequest, ...grpc.CallOption) (*pb.GetBlockchainInfoResponse, error)
	getBlockchainInfoMutex       sync.RWMutex
	getBlockchainInfoArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetBlockchainInfoRequest
		arg3 []grpc.CallOption
	}
	getBlockchainInfoReturns struct {
		result1 *pb.GetBlockchainInfoResponse
		result2 error
	}
	getBlockchainInfoReturnsOnCall map[int]struct {
		result1 *pb.GetBlockchainInfoResponse
		result2 error
	}
	GetHeadersStub        func(context.Context, *pb.GetHeadersRequest, ...grpc.CallOption) (*pb.GetHeadersResponse, error)
	getHeadersMutex       sync.RWMutex
	getHeadersArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetHeadersRequest
		arg3 []grpc.CallOption
	}
	getHeadersReturns struct {
		result1 *pb.GetHeadersResponse
		result2 error
	}
	getHeadersReturnsOnCall map[int]struct {
		result1 *pb.GetHeadersResponse
		result2 error
	}
	GetMempoolInfoStub        func(context.Context, *pb.GetMempoolInfoRequest, ...grpc.CallOption) (*pb.GetMempoolInfoResponse, error)
	getMempoolInfoMutex       sync.RWMutex
	getMempoolInfoArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetMempoolInfoRequest
		arg3 []grpc.CallOption
	}
	getMempoolInfoReturns struct {
		result1 *pb.GetMempoolInfoResponse
		result2 error
	}
	getMempoolInfoReturnsOnCall map[int]struct {
		result1 *pb.GetMempoolInfoResponse
		result2 error
	}
	GetMerkleProofStub        func(context.Context, *pb.GetMerkleProofRequest, ...grpc.CallOption) (*pb.GetMerkleProofResponse, error)
	getMerkleProofMutex       sync.RWMutex
	getMerkleProofArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetMerkleProofRequest
		arg3 []grpc.CallOption
	}
	getMerkleProofReturns struct {
		result1 *pb.GetMerkleProofResponse
		result2 error
	}
	getMerkleProofReturnsOnCall map[int]struct {
		result1 *pb.GetMerkleProofResponse
		result2 error
	}
	GetRawAddressTransactionsStub        func(context.Context, *pb.GetRawAddressTransactionsRequest, ...grpc.CallOption) (*pb.GetRawAddressTransactionsResponse, error)
	getRawAddressTransactionsMutex       sync.RWMutex
	getRawAddressTransactionsArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetRawAddressTransactionsRequest
		arg3 []grpc.CallOption
	}
	getRawAddressTransactionsReturns struct {
		result1 *pb.GetRawAddressTransactionsResponse
		result2 error
	}
	getRawAddressTransactionsReturnsOnCall map[int]struct {
		result1 *pb.GetRawAddressTransactionsResponse
		result2 error
	}
	GetRawBlockStub        func(context.Context, *pb.GetRawBlockRequest, ...grpc.CallOption) (*pb.GetRawBlockResponse, error)
	getRawBlockMutex       sync.RWMutex
	getRawBlockArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetRawBlockRequest
		arg3 []grpc.CallOption
	}
	getRawBlockReturns struct {
		result1 *pb.GetRawBlockResponse
		result2 error
	}
	getRawBlockReturnsOnCall map[int]struct {
		result1 *pb.GetRawBlockResponse
		result2 error
	}
	GetRawTransactionStub        func(context.Context, *pb.GetRawTransactionRequest, ...grpc.CallOption) (*pb.GetRawTransactionResponse, error)
	getRawTransactionMutex       sync.RWMutex
	getRawTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetRawTransactionRequest
		arg3 []grpc.CallOption
	}
	getRawTransactionReturns struct {
		result1 *pb.GetRawTransactionResponse
		result2 error
	}
	getRawTransactionReturnsOnCall map[int]struct {
		result1 *pb.GetRawTransactionResponse
		result2 error
	}
	GetTransactionStub        func(context.Context, *pb.GetTransactionRequest, ...grpc.CallOption) (*pb.GetTransactionResponse, error)
	getTransactionMutex       sync.RWMutex
	getTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.GetTransactionRequest
		arg3 []grpc.CallOption
	}
	getTransactionReturns struct {
		result1 *pb.GetTransactionResponse
		result2 error
	}
	getTransactionReturnsOnCall map[int]struct {
		result1 *pb.GetTransactionResponse
		result2 error
	}
	SubmitTransactionStub        func(context.Context, *pb.SubmitTransactionRequest, ...grpc.CallOption) (*pb.SubmitTransactionResponse, error)
	submitTransactionMutex       sync.RWMutex
	submitTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.SubmitTransactionRequest
		arg3 []grpc.CallOption
	}
	submitTransactionReturns struct {
		result1 *pb.SubmitTransactionResponse
		result2 error
	}
	submitTransactionReturnsOnCall map[int]struct {
		result1 *pb.SubmitTransactionResponse
		result2 error
	}
	SubscribeBlocksStub        func(context.Context, *pb.SubscribeBlocksRequest, ...grpc.CallOption) (pb.Bchrpc_SubscribeBlocksClient, error)
	subscribeBlocksMutex       sync.RWMutex
	subscribeBlocksArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.SubscribeBlocksRequest
		arg3 []grpc.CallOption
	}
	subscribeBlocksReturns struct {
		result1 pb.Bchrpc_SubscribeBlocksClient
		result2 error
	}
	subscribeBlocksReturnsOnCall map[int]struct {
		result1 pb.Bchrpc_SubscribeBlocksClient
		result2 error
	}
	SubscribeTransactionStreamStub        func(context.Context, ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionStreamClient, error)
	subscribeTransactionStreamMutex       sync.RWMutex
	subscribeTransactionStreamArgsForCall []struct {
		arg1 context.Context
		arg2 []grpc.CallOption
	}
	subscribeTransactionStreamReturns struct {
		result1 pb.Bchrpc_SubscribeTransactionStreamClient
		result2 error
	}
	subscribeTransactionStreamReturnsOnCall map[int]struct {
		result1 pb.Bchrpc_SubscribeTransactionStreamClient
		result2 error
	}
	SubscribeTransactionsStub        func(context.Context, *pb.SubscribeTransactionsRequest, ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionsClient, error)
	subscribeTransactionsMutex       sync.RWMutex
	subscribeTransactionsArgsForCall []struct {
		arg1 context.Context
		arg2 *pb.SubscribeTransactionsRequest
		arg3 []grpc.CallOption
	}
	subscribeTransactionsReturns struct {
		result1 pb.Bchrpc_SubscribeTransactionsClient
		result2 error
	}
	subscribeTransactionsReturnsOnCall map[int]struct {
		result1 pb.Bchrpc_SubscribeTransactionsClient
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBchrpcClient) GetAddressTransactions(arg1 context.Context, arg2 *pb.GetAddressTransactionsRequest, arg3 ...grpc.CallOption) (*pb.GetAddressTransactionsResponse, error) {
	fake.getAddressTransactionsMutex.Lock()
	ret, specificReturn := fake.getAddressTransactionsReturnsOnCall[len(fake.getAddressTransactionsArgsForCall)]
	fake.getAddressTransactionsArgsForCall = append(fake.getAddressTransactionsArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetAddressTransactionsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetAddressTransactions", []interface{}{arg1, arg2, arg3})
	fake.getAddressTransactionsMutex.Unlock()
	if fake.GetAddressTransactionsStub != nil {
		return fake.GetAddressTransactionsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAddressTransactionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetAddressTransactionsCallCount() int {
	fake.getAddressTransactionsMutex.RLock()
	defer fake.getAddressTransactionsMutex.RUnlock()
	return len(fake.getAddressTransactionsArgsForCall)
}

func (fake *FakeBchrpcClient) GetAddressTransactionsCalls(stub func(context.Context, *pb.GetAddressTransactionsRequest, ...grpc.CallOption) (*pb.GetAddressTransactionsResponse, error)) {
	fake.getAddressTransactionsMutex.Lock()
	defer fake.getAddressTransactionsMutex.Unlock()
	fake.GetAddressTransactionsStub = stub
}

func (fake *FakeBchrpcClient) GetAddressTransactionsArgsForCall(i int) (context.Context, *pb.GetAddressTransactionsRequest, []grpc.CallOption) {
	fake.getAddressTransactionsMutex.RLock()
	defer fake.getAddressTransactionsMutex.RUnlock()
	argsForCall := fake.getAddressTransactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetAddressTransactionsReturns(result1 *pb.GetAddressTransactionsResponse, result2 error) {
	fake.getAddressTransactionsMutex.Lock()
	defer fake.getAddressTransactionsMutex.Unlock()
	fake.GetAddressTransactionsStub = nil
	fake.getAddressTransactionsReturns = struct {
		result1 *pb.GetAddressTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetAddressTransactionsReturnsOnCall(i int, result1 *pb.GetAddressTransactionsResponse, result2 error) {
	fake.getAddressTransactionsMutex.Lock()
	defer fake.getAddressTransactionsMutex.Unlock()
	fake.GetAddressTransactionsStub = nil
	if fake.getAddressTransactionsReturnsOnCall == nil {
		fake.getAddressTransactionsReturnsOnCall = make(map[int]struct {
			result1 *pb.GetAddressTransactionsResponse
			result2 error
		})
	}
	fake.getAddressTransactionsReturnsOnCall[i] = struct {
		result1 *pb.GetAddressTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputs(arg1 context.Context, arg2 *pb.GetAddressUnspentOutputsRequest, arg3 ...grpc.CallOption) (*pb.GetAddressUnspentOutputsResponse, error) {
	fake.getAddressUnspentOutputsMutex.Lock()
	ret, specificReturn := fake.getAddressUnspentOutputsReturnsOnCall[len(fake.getAddressUnspentOutputsArgsForCall)]
	fake.getAddressUnspentOutputsArgsForCall = append(fake.getAddressUnspentOutputsArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetAddressUnspentOutputsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetAddressUnspentOutputs", []interface{}{arg1, arg2, arg3})
	fake.getAddressUnspentOutputsMutex.Unlock()
	if fake.GetAddressUnspentOutputsStub != nil {
		return fake.GetAddressUnspentOutputsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAddressUnspentOutputsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputsCallCount() int {
	fake.getAddressUnspentOutputsMutex.RLock()
	defer fake.getAddressUnspentOutputsMutex.RUnlock()
	return len(fake.getAddressUnspentOutputsArgsForCall)
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputsCalls(stub func(context.Context, *pb.GetAddressUnspentOutputsRequest, ...grpc.CallOption) (*pb.GetAddressUnspentOutputsResponse, error)) {
	fake.getAddressUnspentOutputsMutex.Lock()
	defer fake.getAddressUnspentOutputsMutex.Unlock()
	fake.GetAddressUnspentOutputsStub = stub
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputsArgsForCall(i int) (context.Context, *pb.GetAddressUnspentOutputsRequest, []grpc.CallOption) {
	fake.getAddressUnspentOutputsMutex.RLock()
	defer fake.getAddressUnspentOutputsMutex.RUnlock()
	argsForCall := fake.getAddressUnspentOutputsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputsReturns(result1 *pb.GetAddressUnspentOutputsResponse, result2 error) {
	fake.getAddressUnspentOutputsMutex.Lock()
	defer fake.getAddressUnspentOutputsMutex.Unlock()
	fake.GetAddressUnspentOutputsStub = nil
	fake.getAddressUnspentOutputsReturns = struct {
		result1 *pb.GetAddressUnspentOutputsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetAddressUnspentOutputsReturnsOnCall(i int, result1 *pb.GetAddressUnspentOutputsResponse, result2 error) {
	fake.getAddressUnspentOutputsMutex.Lock()
	defer fake.getAddressUnspentOutputsMutex.Unlock()
	fake.GetAddressUnspentOutputsStub = nil
	if fake.getAddressUnspentOutputsReturnsOnCall == nil {
		fake.getAddressUnspentOutputsReturnsOnCall = make(map[int]struct {
			result1 *pb.GetAddressUnspentOutputsResponse
			result2 error
		})
	}
	fake.getAddressUnspentOutputsReturnsOnCall[i] = struct {
		result1 *pb.GetAddressUnspentOutputsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlock(arg1 context.Context, arg2 *pb.GetBlockRequest, arg3 ...grpc.CallOption) (*pb.GetBlockResponse, error) {
	fake.getBlockMutex.Lock()
	ret, specificReturn := fake.getBlockReturnsOnCall[len(fake.getBlockArgsForCall)]
	fake.getBlockArgsForCall = append(fake.getBlockArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetBlockRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBlock", []interface{}{arg1, arg2, arg3})
	fake.getBlockMutex.Unlock()
	if fake.GetBlockStub != nil {
		return fake.GetBlockStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBlockReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetBlockCallCount() int {
	fake.getBlockMutex.RLock()
	defer fake.getBlockMutex.RUnlock()
	return len(fake.getBlockArgsForCall)
}

func (fake *FakeBchrpcClient) GetBlockCalls(stub func(context.Context, *pb.GetBlockRequest, ...grpc.CallOption) (*pb.GetBlockResponse, error)) {
	fake.getBlockMutex.Lock()
	defer fake.getBlockMutex.Unlock()
	fake.GetBlockStub = stub
}

func (fake *FakeBchrpcClient) GetBlockArgsForCall(i int) (context.Context, *pb.GetBlockRequest, []grpc.CallOption) {
	fake.getBlockMutex.RLock()
	defer fake.getBlockMutex.RUnlock()
	argsForCall := fake.getBlockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetBlockReturns(result1 *pb.GetBlockResponse, result2 error) {
	fake.getBlockMutex.Lock()
	defer fake.getBlockMutex.Unlock()
	fake.GetBlockStub = nil
	fake.getBlockReturns = struct {
		result1 *pb.GetBlockResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockReturnsOnCall(i int, result1 *pb.GetBlockResponse, result2 error) {
	fake.getBlockMutex.Lock()
	defer fake.getBlockMutex.Unlock()
	fake.GetBlockStub = nil
	if fake.getBlockReturnsOnCall == nil {
		fake.getBlockReturnsOnCall = make(map[int]struct {
			result1 *pb.GetBlockResponse
			result2 error
		})
	}
	fake.getBlockReturnsOnCall[i] = struct {
		result1 *pb.GetBlockResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockFilter(arg1 context.Context, arg2 *pb.GetBlockFilterRequest, arg3 ...grpc.CallOption) (*pb.GetBlockFilterResponse, error) {
	fake.getBlockFilterMutex.Lock()
	ret, specificReturn := fake.getBlockFilterReturnsOnCall[len(fake.getBlockFilterArgsForCall)]
	fake.getBlockFilterArgsForCall = append(fake.getBlockFilterArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetBlockFilterRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBlockFilter", []interface{}{arg1, arg2, arg3})
	fake.getBlockFilterMutex.Unlock()
	if fake.GetBlockFilterStub != nil {
		return fake.GetBlockFilterStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBlockFilterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetBlockFilterCallCount() int {
	fake.getBlockFilterMutex.RLock()
	defer fake.getBlockFilterMutex.RUnlock()
	return len(fake.getBlockFilterArgsForCall)
}

func (fake *FakeBchrpcClient) GetBlockFilterCalls(stub func(context.Context, *pb.GetBlockFilterRequest, ...grpc.CallOption) (*pb.GetBlockFilterResponse, error)) {
	fake.getBlockFilterMutex.Lock()
	defer fake.getBlockFilterMutex.Unlock()
	fake.GetBlockFilterStub = stub
}

func (fake *FakeBchrpcClient) GetBlockFilterArgsForCall(i int) (context.Context, *pb.GetBlockFilterRequest, []grpc.CallOption) {
	fake.getBlockFilterMutex.RLock()
	defer fake.getBlockFilterMutex.RUnlock()
	argsForCall := fake.getBlockFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetBlockFilterReturns(result1 *pb.GetBlockFilterResponse, result2 error) {
	fake.getBlockFilterMutex.Lock()
	defer fake.getBlockFilterMutex.Unlock()
	fake.GetBlockFilterStub = nil
	fake.getBlockFilterReturns = struct {
		result1 *pb.GetBlockFilterResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockFilterReturnsOnCall(i int, result1 *pb.GetBlockFilterResponse, result2 error) {
	fake.getBlockFilterMutex.Lock()
	defer fake.getBlockFilterMutex.Unlock()
	fake.GetBlockFilterStub = nil
	if fake.getBlockFilterReturnsOnCall == nil {
		fake.getBlockFilterReturnsOnCall = make(map[int]struct {
			result1 *pb.GetBlockFilterResponse
			result2 error
		})
	}
	fake.getBlockFilterReturnsOnCall[i] = struct {
		result1 *pb.GetBlockFilterResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockInfo(arg1 context.Context, arg2 *pb.GetBlockInfoRequest, arg3 ...grpc.CallOption) (*pb.GetBlockInfoResponse, error) {
	fake.getBlockInfoMutex.Lock()
	ret, specificReturn := fake.getBlockInfoReturnsOnCall[len(fake.getBlockInfoArgsForCall)]
	fake.getBlockInfoArgsForCall = append(fake.getBlockInfoArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetBlockInfoRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBlockInfo", []interface{}{arg1, arg2, arg3})
	fake.getBlockInfoMutex.Unlock()
	if fake.GetBlockInfoStub != nil {
		return fake.GetBlockInfoStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBlockInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetBlockInfoCallCount() int {
	fake.getBlockInfoMutex.RLock()
	defer fake.getBlockInfoMutex.RUnlock()
	return len(fake.getBlockInfoArgsForCall)
}

func (fake *FakeBchrpcClient) GetBlockInfoCalls(stub func(context.Context, *pb.GetBlockInfoRequest, ...grpc.CallOption) (*pb.GetBlockInfoResponse, error)) {
	fake.getBlockInfoMutex.Lock()
	defer fake.getBlockInfoMutex.Unlock()
	fake.GetBlockInfoStub = stub
}

func (fake *FakeBchrpcClient) GetBlockInfoArgsForCall(i int) (context.Context, *pb.GetBlockInfoRequest, []grpc.CallOption) {
	fake.getBlockInfoMutex.RLock()
	defer fake.getBlockInfoMutex.RUnlock()
	argsForCall := fake.getBlockInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetBlockInfoReturns(result1 *pb.GetBlockInfoResponse, result2 error) {
	fake.getBlockInfoMutex.Lock()
	defer fake.getBlockInfoMutex.Unlock()
	fake.GetBlockInfoStub = nil
	fake.getBlockInfoReturns = struct {
		result1 *pb.GetBlockInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockInfoReturnsOnCall(i int, result1 *pb.GetBlockInfoResponse, result2 error) {
	fake.getBlockInfoMutex.Lock()
	defer fake.getBlockInfoMutex.Unlock()
	fake.GetBlockInfoStub = nil
	if fake.getBlockInfoReturnsOnCall == nil {
		fake.getBlockInfoReturnsOnCall = make(map[int]struct {
			result1 *pb.GetBlockInfoResponse
			result2 error
		})
	}
	fake.getBlockInfoReturnsOnCall[i] = struct {
		result1 *pb.GetBlockInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockchainInfo(arg1 context.Context, arg2 *pb.GetBlockchainInfoRequest, arg3 ...grpc.CallOption) (*pb.GetBlockchainInfoResponse, error) {
	fake.getBlockchainInfoMutex.Lock()
	ret, specificReturn := fake.getBlockchainInfoReturnsOnCall[len(fake.getBlockchainInfoArgsForCall)]
	fake.getBlockchainInfoArgsForCall = append(fake.getBlockchainInfoArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetBlockchainInfoRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetBlockchainInfo", []interface{}{arg1, arg2, arg3})
	fake.getBlockchainInfoMutex.Unlock()
	if fake.GetBlockchainInfoStub != nil {
		return fake.GetBlockchainInfoStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBlockchainInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetBlockchainInfoCallCount() int {
	fake.getBlockchainInfoMutex.RLock()
	defer fake.getBlockchainInfoMutex.RUnlock()
	return len(fake.getBlockchainInfoArgsForCall)
}

func (fake *FakeBchrpcClient) GetBlockchainInfoCalls(stub func(context.Context, *pb.GetBlockchainInfoRequest, ...grpc.CallOption) (*pb.GetBlockchainInfoResponse, error)) {
	fake.getBlockchainInfoMutex.Lock()
	defer fake.getBlockchainInfoMutex.Unlock()
	fake.GetBlockchainInfoStub = stub
}

func (fake *FakeBchrpcClient) GetBlockchainInfoArgsForCall(i int) (context.Context, *pb.GetBlockchainInfoRequest, []grpc.CallOption) {
	fake.getBlockchainInfoMutex.RLock()
	defer fake.getBlockchainInfoMutex.RUnlock()
	argsForCall := fake.getBlockchainInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetBlockchainInfoReturns(result1 *pb.GetBlockchainInfoResponse, result2 error) {
	fake.getBlockchainInfoMutex.Lock()
	defer fake.getBlockchainInfoMutex.Unlock()
	fake.GetBlockchainInfoStub = nil
	fake.getBlockchainInfoReturns = struct {
		result1 *pb.GetBlockchainInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetBlockchainInfoReturnsOnCall(i int, result1 *pb.GetBlockchainInfoResponse, result2 error) {
	fake.getBlockchainInfoMutex.Lock()
	defer fake.getBlockchainInfoMutex.Unlock()
	fake.GetBlockchainInfoStub = nil
	if fake.getBlockchainInfoReturnsOnCall == nil {
		fake.getBlockchainInfoReturnsOnCall = make(map[int]struct {
			result1 *pb.GetBlockchainInfoResponse
			result2 error
		})
	}
	fake.getBlockchainInfoReturnsOnCall[i] = struct {
		result1 *pb.GetBlockchainInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetHeaders(arg1 context.Context, arg2 *pb.GetHeadersRequest, arg3 ...grpc.CallOption) (*pb.GetHeadersResponse, error) {
	fake.getHeadersMutex.Lock()
	ret, specificReturn := fake.getHeadersReturnsOnCall[len(fake.getHeadersArgsForCall)]
	fake.getHeadersArgsForCall = append(fake.getHeadersArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetHeadersRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetHeaders", []interface{}{arg1, arg2, arg3})
	fake.getHeadersMutex.Unlock()
	if fake.GetHeadersStub != nil {
		return fake.GetHeadersStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getHeadersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetHeadersCallCount() int {
	fake.getHeadersMutex.RLock()
	defer fake.getHeadersMutex.RUnlock()
	return len(fake.getHeadersArgsForCall)
}

func (fake *FakeBchrpcClient) GetHeadersCalls(stub func(context.Context, *pb.GetHeadersRequest, ...grpc.CallOption) (*pb.GetHeadersResponse, error)) {
	fake.getHeadersMutex.Lock()
	defer fake.getHeadersMutex.Unlock()
	fake.GetHeadersStub = stub
}

func (fake *FakeBchrpcClient) GetHeadersArgsForCall(i int) (context.Context, *pb.GetHeadersRequest, []grpc.CallOption) {
	fake.getHeadersMutex.RLock()
	defer fake.getHeadersMutex.RUnlock()
	argsForCall := fake.getHeadersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetHeadersReturns(result1 *pb.GetHeadersResponse, result2 error) {
	fake.getHeadersMutex.Lock()
	defer fake.getHeadersMutex.Unlock()
	fake.GetHeadersStub = nil
	fake.getHeadersReturns = struct {
		result1 *pb.GetHeadersResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetHeadersReturnsOnCall(i int, result1 *pb.GetHeadersResponse, result2 error) {
	fake.getHeadersMutex.Lock()
	defer fake.getHeadersMutex.Unlock()
	fake.GetHeadersStub = nil
	if fake.getHeadersReturnsOnCall == nil {
		fake.getHeadersReturnsOnCall = make(map[int]struct {
			result1 *pb.GetHeadersResponse
			result2 error
		})
	}
	fake.getHeadersReturnsOnCall[i] = struct {
		result1 *pb.GetHeadersResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetMempoolInfo(arg1 context.Context, arg2 *pb.GetMempoolInfoRequest, arg3 ...grpc.CallOption) (*pb.GetMempoolInfoResponse, error) {
	fake.getMempoolInfoMutex.Lock()
	ret, specificReturn := fake.getMempoolInfoReturnsOnCall[len(fake.getMempoolInfoArgsForCall)]
	fake.getMempoolInfoArgsForCall = append(fake.getMempoolInfoArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetMempoolInfoRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetMempoolInfo", []interface{}{arg1, arg2, arg3})
	fake.getMempoolInfoMutex.Unlock()
	if fake.GetMempoolInfoStub != nil {
		return fake.GetMempoolInfoStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getMempoolInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetMempoolInfoCallCount() int {
	fake.getMempoolInfoMutex.RLock()
	defer fake.getMempoolInfoMutex.RUnlock()
	return len(fake.getMempoolInfoArgsForCall)
}

func (fake *FakeBchrpcClient) GetMempoolInfoCalls(stub func(context.Context, *pb.GetMempoolInfoRequest, ...grpc.CallOption) (*pb.GetMempoolInfoResponse, error)) {
	fake.getMempoolInfoMutex.Lock()
	defer fake.getMempoolInfoMutex.Unlock()
	fake.GetMempoolInfoStub = stub
}

func (fake *FakeBchrpcClient) GetMempoolInfoArgsForCall(i int) (context.Context, *pb.GetMempoolInfoRequest, []grpc.CallOption) {
	fake.getMempoolInfoMutex.RLock()
	defer fake.getMempoolInfoMutex.RUnlock()
	argsForCall := fake.getMempoolInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetMempoolInfoReturns(result1 *pb.GetMempoolInfoResponse, result2 error) {
	fake.getMempoolInfoMutex.Lock()
	defer fake.getMempoolInfoMutex.Unlock()
	fake.GetMempoolInfoStub = nil
	fake.getMempoolInfoReturns = struct {
		result1 *pb.GetMempoolInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetMempoolInfoReturnsOnCall(i int, result1 *pb.GetMempoolInfoResponse, result2 error) {
	fake.getMempoolInfoMutex.Lock()
	defer fake.getMempoolInfoMutex.Unlock()
	fake.GetMempoolInfoStub = nil
	if fake.getMempoolInfoReturnsOnCall == nil {
		fake.getMempoolInfoReturnsOnCall = make(map[int]struct {
			result1 *pb.GetMempoolInfoResponse
			result2 error
		})
	}
	fake.getMempoolInfoReturnsOnCall[i] = struct {
		result1 *pb.GetMempoolInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetMerkleProof(arg1 context.Context, arg2 *pb.GetMerkleProofRequest, arg3 ...grpc.CallOption) (*pb.GetMerkleProofResponse, error) {
	fake.getMerkleProofMutex.Lock()
	ret, specificReturn := fake.getMerkleProofReturnsOnCall[len(fake.getMerkleProofArgsForCall)]
	fake.getMerkleProofArgsForCall = append(fake.getMerkleProofArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetMerkleProofRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetMerkleProof", []interface{}{arg1, arg2, arg3})
	fake.getMerkleProofMutex.Unlock()
	if fake.GetMerkleProofStub != nil {
		return fake.GetMerkleProofStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getMerkleProofReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetMerkleProofCallCount() int {
	fake.getMerkleProofMutex.RLock()
	defer fake.getMerkleProofMutex.RUnlock()
	return len(fake.getMerkleProofArgsForCall)
}

func (fake *FakeBchrpcClient) GetMerkleProofCalls(stub func(context.Context, *pb.GetMerkleProofRequest, ...grpc.CallOption) (*pb.GetMerkleProofResponse, error)) {
	fake.getMerkleProofMutex.Lock()
	defer fake.getMerkleProofMutex.Unlock()
	fake.GetMerkleProofStub = stub
}

func (fake *FakeBchrpcClient) GetMerkleProofArgsForCall(i int) (context.Context, *pb.GetMerkleProofRequest, []grpc.CallOption) {
	fake.getMerkleProofMutex.RLock()
	defer fake.getMerkleProofMutex.RUnlock()
	argsForCall := fake.getMerkleProofArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetMerkleProofReturns(result1 *pb.GetMerkleProofResponse, result2 error) {
	fake.getMerkleProofMutex.Lock()
	defer fake.getMerkleProofMutex.Unlock()
	fake.GetMerkleProofStub = nil
	fake.getMerkleProofReturns = struct {
		result1 *pb.GetMerkleProofResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetMerkleProofReturnsOnCall(i int, result1 *pb.GetMerkleProofResponse, result2 error) {
	fake.getMerkleProofMutex.Lock()
	defer fake.getMerkleProofMutex.Unlock()
	fake.GetMerkleProofStub = nil
	if fake.getMerkleProofReturnsOnCall == nil {
		fake.getMerkleProofReturnsOnCall = make(map[int]struct {
			result1 *pb.GetMerkleProofResponse
			result2 error
		})
	}
	fake.getMerkleProofReturnsOnCall[i] = struct {
		result1 *pb.GetMerkleProofResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawAddressTransactions(arg1 context.Context, arg2 *pb.GetRawAddressTransactionsRequest, arg3 ...grpc.CallOption) (*pb.GetRawAddressTransactionsResponse, error) {
	fake.getRawAddressTransactionsMutex.Lock()
	ret, specificReturn := fake.getRawAddressTransactionsReturnsOnCall[len(fake.getRawAddressTransactionsArgsForCall)]
	fake.getRawAddressTransactionsArgsForCall = append(fake.getRawAddressTransactionsArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetRawAddressTransactionsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetRawAddressTransactions", []interface{}{arg1, arg2, arg3})
	fake.getRawAddressTransactionsMutex.Unlock()
	if fake.GetRawAddressTransactionsStub != nil {
		return fake.GetRawAddressTransactionsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRawAddressTransactionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetRawAddressTransactionsCallCount() int {
	fake.getRawAddressTransactionsMutex.RLock()
	defer fake.getRawAddressTransactionsMutex.RUnlock()
	return len(fake.getRawAddressTransactionsArgsForCall)
}

func (fake *FakeBchrpcClient) GetRawAddressTransactionsCalls(stub func(context.Context, *pb.GetRawAddressTransactionsRequest, ...grpc.CallOption) (*pb.GetRawAddressTransactionsResponse, error)) {
	fake.getRawAddressTransactionsMutex.Lock()
	defer fake.getRawAddressTransactionsMutex.Unlock()
	fake.GetRawAddressTransactionsStub = stub
}

func (fake *FakeBchrpcClient) GetRawAddressTransactionsArgsForCall(i int) (context.Context, *pb.GetRawAddressTransactionsRequest, []grpc.CallOption) {
	fake.getRawAddressTransactionsMutex.RLock()
	defer fake.getRawAddressTransactionsMutex.RUnlock()
	argsForCall := fake.getRawAddressTransactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetRawAddressTransactionsReturns(result1 *pb.GetRawAddressTransactionsResponse, result2 error) {
	fake.getRawAddressTransactionsMutex.Lock()
	defer fake.getRawAddressTransactionsMutex.Unlock()
	fake.GetRawAddressTransactionsStub = nil
	fake.getRawAddressTransactionsReturns = struct {
		result1 *pb.GetRawAddressTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawAddressTransactionsReturnsOnCall(i int, result1 *pb.GetRawAddressTransactionsResponse, result2 error) {
	fake.getRawAddressTransactionsMutex.Lock()
	defer fake.getRawAddressTransactionsMutex.Unlock()
	fake.GetRawAddressTransactionsStub = nil
	if fake.getRawAddressTransactionsReturnsOnCall == nil {
		fake.getRawAddressTransactionsReturnsOnCall = make(map[int]struct {
			result1 *pb.GetRawAddressTransactionsResponse
			result2 error
		})
	}
	fake.getRawAddressTransactionsReturnsOnCall[i] = struct {
		result1 *pb.GetRawAddressTransactionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawBlock(arg1 context.Context, arg2 *pb.GetRawBlockRequest, arg3 ...grpc.CallOption) (*pb.GetRawBlockResponse, error) {
	fake.getRawBlockMutex.Lock()
	ret, specificReturn := fake.getRawBlockReturnsOnCall[len(fake.getRawBlockArgsForCall)]
	fake.getRawBlockArgsForCall = append(fake.getRawBlockArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetRawBlockRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetRawBlock", []interface{}{arg1, arg2, arg3})
	fake.getRawBlockMutex.Unlock()
	if fake.GetRawBlockStub != nil {
		return fake.GetRawBlockStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRawBlockReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetRawBlockCallCount() int {
	fake.getRawBlockMutex.RLock()
	defer fake.getRawBlockMutex.RUnlock()
	return len(fake.getRawBlockArgsForCall)
}

func (fake *FakeBchrpcClient) GetRawBlockCalls(stub func(context.Context, *pb.GetRawBlockRequest, ...grpc.CallOption) (*pb.GetRawBlockResponse, error)) {
	fake.getRawBlockMutex.Lock()
	defer fake.getRawBlockMutex.Unlock()
	fake.GetRawBlockStub = stub
}

func (fake *FakeBchrpcClient) GetRawBlockArgsForCall(i int) (context.Context, *pb.GetRawBlockRequest, []grpc.CallOption) {
	fake.getRawBlockMutex.RLock()
	defer fake.getRawBlockMutex.RUnlock()
	argsForCall := fake.getRawBlockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetRawBlockReturns(result1 *pb.GetRawBlockResponse, result2 error) {
	fake.getRawBlockMutex.Lock()
	defer fake.getRawBlockMutex.Unlock()
	fake.GetRawBlockStub = nil
	fake.getRawBlockReturns = struct {
		result1 *pb.GetRawBlockResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawBlockReturnsOnCall(i int, result1 *pb.GetRawBlockResponse, result2 error) {
	fake.getRawBlockMutex.Lock()
	defer fake.getRawBlockMutex.Unlock()
	fake.GetRawBlockStub = nil
	if fake.getRawBlockReturnsOnCall == nil {
		fake.getRawBlockReturnsOnCall = make(map[int]struct {
			result1 *pb.GetRawBlockResponse
			result2 error
		})
	}
	fake.getRawBlockReturnsOnCall[i] = struct {
		result1 *pb.GetRawBlockResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawTransaction(arg1 context.Context, arg2 *pb.GetRawTransactionRequest, arg3 ...grpc.CallOption) (*pb.GetRawTransactionResponse, error) {
	fake.getRawTransactionMutex.Lock()
	ret, specificReturn := fake.getRawTransactionReturnsOnCall[len(fake.getRawTransactionArgsForCall)]
	fake.getRawTransactionArgsForCall = append(fake.getRawTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetRawTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetRawTransaction", []interface{}{arg1, arg2, arg3})
	fake.getRawTransactionMutex.Unlock()
	if fake.GetRawTransactionStub != nil {
		return fake.GetRawTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRawTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetRawTransactionCallCount() int {
	fake.getRawTransactionMutex.RLock()
	defer fake.getRawTransactionMutex.RUnlock()
	return len(fake.getRawTransactionArgsForCall)
}

func (fake *FakeBchrpcClient) GetRawTransactionCalls(stub func(context.Context, *pb.GetRawTransactionRequest, ...grpc.CallOption) (*pb.GetRawTransactionResponse, error)) {
	fake.getRawTransactionMutex.Lock()
	defer fake.getRawTransactionMutex.Unlock()
	fake.GetRawTransactionStub = stub
}

func (fake *FakeBchrpcClient) GetRawTransactionArgsForCall(i int) (context.Context, *pb.GetRawTransactionRequest, []grpc.CallOption) {
	fake.getRawTransactionMutex.RLock()
	defer fake.getRawTransactionMutex.RUnlock()
	argsForCall := fake.getRawTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetRawTransactionReturns(result1 *pb.GetRawTransactionResponse, result2 error) {
	fake.getRawTransactionMutex.Lock()
	defer fake.getRawTransactionMutex.Unlock()
	fake.GetRawTransactionStub = nil
	fake.getRawTransactionReturns = struct {
		result1 *pb.GetRawTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetRawTransactionReturnsOnCall(i int, result1 *pb.GetRawTransactionResponse, result2 error) {
	fake.getRawTransactionMutex.Lock()
	defer fake.getRawTransactionMutex.Unlock()
	fake.GetRawTransactionStub = nil
	if fake.getRawTransactionReturnsOnCall == nil {
		fake.getRawTransactionReturnsOnCall = make(map[int]struct {
			result1 *pb.GetRawTransactionResponse
			result2 error
		})
	}
	fake.getRawTransactionReturnsOnCall[i] = struct {
		result1 *pb.GetRawTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetTransaction(arg1 context.Context, arg2 *pb.GetTransactionRequest, arg3 ...grpc.CallOption) (*pb.GetTransactionResponse, error) {
	fake.getTransactionMutex.Lock()
	ret, specificReturn := fake.getTransactionReturnsOnCall[len(fake.getTransactionArgsForCall)]
	fake.getTransactionArgsForCall = append(fake.getTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.GetTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetTransaction", []interface{}{arg1, arg2, arg3})
	fake.getTransactionMutex.Unlock()
	if fake.GetTransactionStub != nil {
		return fake.GetTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) GetTransactionCallCount() int {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	return len(fake.getTransactionArgsForCall)
}

func (fake *FakeBchrpcClient) GetTransactionCalls(stub func(context.Context, *pb.GetTransactionRequest, ...grpc.CallOption) (*pb.GetTransactionResponse, error)) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = stub
}

func (fake *FakeBchrpcClient) GetTransactionArgsForCall(i int) (context.Context, *pb.GetTransactionRequest, []grpc.CallOption) {
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	argsForCall := fake.getTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) GetTransactionReturns(result1 *pb.GetTransactionResponse, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	fake.getTransactionReturns = struct {
		result1 *pb.GetTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) GetTransactionReturnsOnCall(i int, result1 *pb.GetTransactionResponse, result2 error) {
	fake.getTransactionMutex.Lock()
	defer fake.getTransactionMutex.Unlock()
	fake.GetTransactionStub = nil
	if fake.getTransactionReturnsOnCall == nil {
		fake.getTransactionReturnsOnCall = make(map[int]struct {
			result1 *pb.GetTransactionResponse
			result2 error
		})
	}
	fake.getTransactionReturnsOnCall[i] = struct {
		result1 *pb.GetTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubmitTransaction(arg1 context.Context, arg2 *pb.SubmitTransactionRequest, arg3 ...grpc.CallOption) (*pb.SubmitTransactionResponse, error) {
	fake.submitTransactionMutex.Lock()
	ret, specificReturn := fake.submitTransactionReturnsOnCall[len(fake.submitTransactionArgsForCall)]
	fake.submitTransactionArgsForCall = append(fake.submitTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.SubmitTransactionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SubmitTransaction", []interface{}{arg1, arg2, arg3})
	fake.submitTransactionMutex.Unlock()
	if fake.SubmitTransactionStub != nil {
		return fake.SubmitTransactionStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.submitTransactionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) SubmitTransactionCallCount() int {
	fake.submitTransactionMutex.RLock()
	defer fake.submitTransactionMutex.RUnlock()
	return len(fake.submitTransactionArgsForCall)
}

func (fake *FakeBchrpcClient) SubmitTransactionCalls(stub func(context.Context, *pb.SubmitTransactionRequest, ...grpc.CallOption) (*pb.SubmitTransactionResponse, error)) {
	fake.submitTransactionMutex.Lock()
	defer fake.submitTransactionMutex.Unlock()
	fake.SubmitTransactionStub = stub
}

func (fake *FakeBchrpcClient) SubmitTransactionArgsForCall(i int) (context.Context, *pb.SubmitTransactionRequest, []grpc.CallOption) {
	fake.submitTransactionMutex.RLock()
	defer fake.submitTransactionMutex.RUnlock()
	argsForCall := fake.submitTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) SubmitTransactionReturns(result1 *pb.SubmitTransactionResponse, result2 error) {
	fake.submitTransactionMutex.Lock()
	defer fake.submitTransactionMutex.Unlock()
	fake.SubmitTransactionStub = nil
	fake.submitTransactionReturns = struct {
		result1 *pb.SubmitTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubmitTransactionReturnsOnCall(i int, result1 *pb.SubmitTransactionResponse, result2 error) {
	fake.submitTransactionMutex.Lock()
	defer fake.submitTransactionMutex.Unlock()
	fake.SubmitTransactionStub = nil
	if fake.submitTransactionReturnsOnCall == nil {
		fake.submitTransactionReturnsOnCall = make(map[int]struct {
			result1 *pb.SubmitTransactionResponse
			result2 error
		})
	}
	fake.submitTransactionReturnsOnCall[i] = struct {
		result1 *pb.SubmitTransactionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeBlocks(arg1 context.Context, arg2 *pb.SubscribeBlocksRequest, arg3 ...grpc.CallOption) (pb.Bchrpc_SubscribeBlocksClient, error) {
	fake.subscribeBlocksMutex.Lock()
	ret, specificReturn := fake.subscribeBlocksReturnsOnCall[len(fake.subscribeBlocksArgsForCall)]
	fake.subscribeBlocksArgsForCall = append(fake.subscribeBlocksArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.SubscribeBlocksRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SubscribeBlocks", []interface{}{arg1, arg2, arg3})
	fake.subscribeBlocksMutex.Unlock()
	if fake.SubscribeBlocksStub != nil {
		return fake.SubscribeBlocksStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeBlocksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) SubscribeBlocksCallCount() int {
	fake.subscribeBlocksMutex.RLock()
	defer fake.subscribeBlocksMutex.RUnlock()
	return len(fake.subscribeBlocksArgsForCall)
}

func (fake *FakeBchrpcClient) SubscribeBlocksCalls(stub func(context.Context, *pb.SubscribeBlocksRequest, ...grpc.CallOption) (pb.Bchrpc_SubscribeBlocksClient, error)) {
	fake.subscribeBlocksMutex.Lock()
	defer fake.subscribeBlocksMutex.Unlock()
	fake.SubscribeBlocksStub = stub
}

func (fake *FakeBchrpcClient) SubscribeBlocksArgsForCall(i int) (context.Context, *pb.SubscribeBlocksRequest, []grpc.CallOption) {
	fake.subscribeBlocksMutex.RLock()
	defer fake.subscribeBlocksMutex.RUnlock()
	argsForCall := fake.subscribeBlocksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) SubscribeBlocksReturns(result1 pb.Bchrpc_SubscribeBlocksClient, result2 error) {
	fake.subscribeBlocksMutex.Lock()
	defer fake.subscribeBlocksMutex.Unlock()
	fake.SubscribeBlocksStub = nil
	fake.subscribeBlocksReturns = struct {
		result1 pb.Bchrpc_SubscribeBlocksClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeBlocksReturnsOnCall(i int, result1 pb.Bchrpc_SubscribeBlocksClient, result2 error) {
	fake.subscribeBlocksMutex.Lock()
	defer fake.subscribeBlocksMutex.Unlock()
	fake.SubscribeBlocksStub = nil
	if fake.subscribeBlocksReturnsOnCall == nil {
		fake.subscribeBlocksReturnsOnCall = make(map[int]struct {
			result1 pb.Bchrpc_SubscribeBlocksClient
			result2 error
		})
	}
	fake.subscribeBlocksReturnsOnCall[i] = struct {
		result1 pb.Bchrpc_SubscribeBlocksClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeTransactionStream(arg1 context.Context, arg2 ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionStreamClient, error) {
	fake.subscribeTransactionStreamMutex.Lock()
	ret, specificReturn := fake.subscribeTransactionStreamReturnsOnCall[len(fake.subscribeTransactionStreamArgsForCall)]
	fake.subscribeTransactionStreamArgsForCall = append(fake.subscribeTransactionStreamArgsForCall, struct {
		arg1 context.Context
		arg2 []grpc.CallOption
	}{arg1, arg2})
	fake.recordInvocation("SubscribeTransactionStream", []interface{}{arg1, arg2})
	fake.subscribeTransactionStreamMutex.Unlock()
	if fake.SubscribeTransactionStreamStub != nil {
		return fake.SubscribeTransactionStreamStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeTransactionStreamReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) SubscribeTransactionStreamCallCount() int {
	fake.subscribeTransactionStreamMutex.RLock()
	defer fake.subscribeTransactionStreamMutex.RUnlock()
	return len(fake.subscribeTransactionStreamArgsForCall)
}

func (fake *FakeBchrpcClient) SubscribeTransactionStreamCalls(stub func(context.Context, ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionStreamClient, error)) {
	fake.subscribeTransactionStreamMutex.Lock()
	defer fake.subscribeTransactionStreamMutex.Unlock()
	fake.SubscribeTransactionStreamStub = stub
}

func (fake *FakeBchrpcClient) SubscribeTransactionStreamArgsForCall(i int) (context.Context, []grpc.CallOption) {
	fake.subscribeTransactionStreamMutex.RLock()
	defer fake.subscribeTransactionStreamMutex.RUnlock()
	argsForCall := fake.subscribeTransactionStreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBchrpcClient) SubscribeTransactionStreamReturns(result1 pb.Bchrpc_SubscribeTransactionStreamClient, result2 error) {
	fake.subscribeTransactionStreamMutex.Lock()
	defer fake.subscribeTransactionStreamMutex.Unlock()
	fake.SubscribeTransactionStreamStub = nil
	fake.subscribeTransactionStreamReturns = struct {
		result1 pb.Bchrpc_SubscribeTransactionStreamClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeTransactionStreamReturnsOnCall(i int, result1 pb.Bchrpc_SubscribeTransactionStreamClient, result2 error) {
	fake.subscribeTransactionStreamMutex.Lock()
	defer fake.subscribeTransactionStreamMutex.Unlock()
	fake.SubscribeTransactionStreamStub = nil
	if fake.subscribeTransactionStreamReturnsOnCall == nil {
		fake.subscribeTransactionStreamReturnsOnCall = make(map[int]struct {
			result1 pb.Bchrpc_SubscribeTransactionStreamClient
			result2 error
		})
	}
	fake.subscribeTransactionStreamReturnsOnCall[i] = struct {
		result1 pb.Bchrpc_SubscribeTransactionStreamClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeTransactions(arg1 context.Context, arg2 *pb.SubscribeTransactionsRequest, arg3 ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionsClient, error) {
	fake.subscribeTransactionsMutex.Lock()
	ret, specificReturn := fake.subscribeTransactionsReturnsOnCall[len(fake.subscribeTransactionsArgsForCall)]
	fake.subscribeTransactionsArgsForCall = append(fake.subscribeTransactionsArgsForCall, struct {
		arg1 context.Context
		arg2 *pb.SubscribeTransactionsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("SubscribeTransactions", []interface{}{arg1, arg2, arg3})
	fake.subscribeTransactionsMutex.Unlock()
	if fake.SubscribeTransactionsStub != nil {
		return fake.SubscribeTransactionsStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeTransactionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBchrpcClient) SubscribeTransactionsCallCount() int {
	fake.subscribeTransactionsMutex.RLock()
	defer fake.subscribeTransactionsMutex.RUnlock()
	return len(fake.subscribeTransactionsArgsForCall)
}

func (fake *FakeBchrpcClient) SubscribeTransactionsCalls(stub func(context.Context, *pb.SubscribeTransactionsRequest, ...grpc.CallOption) (pb.Bchrpc_SubscribeTransactionsClient, error)) {
	fake.subscribeTransactionsMutex.Lock()
	defer fake.subscribeTransactionsMutex.Unlock()
	fake.SubscribeTransactionsStub = stub
}

func (fake *FakeBchrpcClient) SubscribeTransactionsArgsForCall(i int) (context.Context, *pb.SubscribeTransactionsRequest, []grpc.CallOption) {
	fake.subscribeTransactionsMutex.RLock()
	defer fake.subscribeTransactionsMutex.RUnlock()
	argsForCall := fake.subscribeTransactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBchrpcClient) SubscribeTransactionsReturns(result1 pb.Bchrpc_SubscribeTransactionsClient, result2 error) {
	fake.subscribeTransactionsMutex.Lock()
	defer fake.subscribeTransactionsMutex.Unlock()
	fake.SubscribeTransactionsStub = nil
	fake.subscribeTransactionsReturns = struct {
		result1 pb.Bchrpc_SubscribeTransactionsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) SubscribeTransactionsReturnsOnCall(i int, result1 pb.Bchrpc_SubscribeTransactionsClient, result2 error) {
	fake.subscribeTransactionsMutex.Lock()
	defer fake.subscribeTransactionsMutex.Unlock()
	fake.SubscribeTransactionsStub = nil
	if fake.subscribeTransactionsReturnsOnCall == nil {
		fake.subscribeTransactionsReturnsOnCall = make(map[int]struct {
			result1 pb.Bchrpc_SubscribeTransactionsClient
			result2 error
		})
	}
	fake.subscribeTransactionsReturnsOnCall[i] = struct {
		result1 pb.Bchrpc_SubscribeTransactionsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeBchrpcClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getAddressTransactionsMutex.RLock()
	defer fake.getAddressTransactionsMutex.RUnlock()
	fake.getAddressUnspentOutputsMutex.RLock()
	defer fake.getAddressUnspentOutputsMutex.RUnlock()
	fake.getBlockMutex.RLock()
	defer fake.getBlockMutex.RUnlock()
	fake.getBlockFilterMutex.RLock()
	defer fake.getBlockFilterMutex.RUnlock()
	fake.getBlockInfoMutex.RLock()
	defer fake.getBlockInfoMutex.RUnlock()
	fake.getBlockchainInfoMutex.RLock()
	defer fake.getBlockchainInfoMutex.RUnlock()
	fake.getHeadersMutex.RLock()
	defer fake.getHeadersMutex.RUnlock()
	fake.getMempoolInfoMutex.RLock()
	defer fake.getMempoolInfoMutex.RUnlock()
	fake.getMerkleProofMutex.RLock()
	defer fake.getMerkleProofMutex.RUnlock()
	fake.getRawAddressTransactionsMutex.RLock()
	defer fake.getRawAddressTransactionsMutex.RUnlock()
	fake.getRawBlockMutex.RLock()
	defer fake.getRawBlockMutex.RUnlock()
	fake.getRawTransactionMutex.RLock()
	defer fake.getRawTransactionMutex.RUnlock()
	fake.getTransactionMutex.RLock()
	defer fake.getTransactionMutex.RUnlock()
	fake.submitTransactionMutex.RLock()
	defer fake.submitTransactionMutex.RUnlock()
	fake.subscribeBlocksMutex.RLock()
	defer fake.subscribeBlocksMutex.RUnlock()
	fake.subscribeTransactionStreamMutex.RLock()
	defer fake.subscribeTransactionStreamMutex.RUnlock()
	fake.subscribeTransactionsMutex.RLock()
	defer fake.subscribeTransactionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBchrpcClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pb.BchrpcClient = new(FakeBchrpcClient)
